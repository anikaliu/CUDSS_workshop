---
title: "CUDSS_R_Data_Vis"
author: "ls760 and Anika"
date: "12/01/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Reminder/Disclaimer

To follow the workshop you should have already a basic knowledge of R/coding. 
Fully charged laptop or charger
Have R and Rstudio installed on your laptop

## Import the data

Firstly, let's import the packages we are going to use for this workshop. Packages are sets of functions which you can download and they allow you to extend R basic functions. In this workshop we will mainly use "tidyverse". Tidyverse is a collection of packages designed to mung and visualise data, key tasks in data science. For more info about Tidyverse go on: https://www.tidyverse.org/

Secondly we import the data set we want to work on. For this workshop, we selected some data publicly available at http://www-huber.embl.de/users/klaus/BasicR/bodyfat.rda. They are made available from Bernd Klaus (EMBL) and used as teaching material for a few R courses. You will find the data in the GitHub repository ("bodyfat.csv"). 

```{R load libraries and import the data}
# For this workshop we will need the packages "tidyverse" and "reshape2". 
# Therefore we first install them (this has to be done only once).  
install.packages('tidyverse')
install.packages('reshape2')

# Next, we load them into the current session.
library(tidyverse)
library(reshape2)

# We import and store the data from the file "bodyfat.csv" in an R dataframe. 
# We set col_names to TRUE in this case, as every column has a header and we want to keep it as column name. 
bd_fat_df <- read_csv("bodyfat.csv", col_names = TRUE) 

# N.B. the data frame probably has data collected in U.S. and hight and weight units are in pound and inches.

# To understand what a function is doing, how to use it and what variables it takes as input ?<function_name> (e.g. ?dim) gives some information about the function and its grammar. help(<function_name>) has a similar use. For example

help(read_csv)
?read_csv
#Or for a broader search:
??read_csv
```

If you can't import the data, most likely the working directory is set to a different path and so R doesn't find the file it is looking for. You have 2 solutions to this problem:

1) change the file path: 
  e.g. "/path/to/directory/bodyfat.csv"
2) change the working directory. In this case 2 commands are useful: getwd() and setwd(). getwd() tells you what is the direcotry R is working in (e.g. ~/) and setwd() change the working directory to the one you want (e.g. "/path/to/directory/") so that the file will be in the same directory R is working in. Another alternative is to click your way through: Session-> Set working directory -

## Explore the data

It is a good practice to explore a bit your data before starting to work with them. It is helpful to understand what kind of data you are looking at, if there were any mistakes while importing them, if the dataset is "clean" or it needs some wrangling and so on.

Good functions to quickly explore your data frame are dim(), summary(), head()

```{r basic functions}

# To show the row and column number of the data frame use dim(). If you are expecting 2000 observation or 30 variables, then you might have spotted a mistake.

dim(bd_fat_df)

# Head is used to visualize the first 10 (in this case) lines of the dataframe
head(bd_fat_df, n = 10) 

# Summary prints a short stats report of the data frame, one per column
summary(bd_fat_df)

```


## Subset the data set

Quite often datasets can grow very big, slowing down all the analysis. So in this cases it might be handy to take only a part of the dataset. It may be also useful to have a smaller dataset when you need to check a new script or to create a training dataset (in this last case the subset would be made in a different way).

Let's say we are just interested in people over 40 y.o. and it doesn't make much sense to have the entire dataset in our analysis. How could we subset the dataframe?

```{r subset data frame}

# To have only the row that have mathing condition we can use the filter() function, which is a function of the Tidyverse/dplyr package. 
# In this case, filter asks to return only the rows which have a value over 40 in the column age. We store it in another variable, a new dataframe, called "bd_fat_df40"

bd_fat_df40 <- bd_fat_df %>% 
               filter(age > 40 ) 

# N.B.: In R you can use number and some special caracters in the variable name, but not at the beginning of the variable name
```

"%>%"  this simbol is called "pipe".It is a useful way to pass information from one function to the following one. In the previous case I asked to read the bd_fat_df and then to filter out the row that have a value in age of 40 or below.

Question: Have a look at the filter function grammar. How could you have the same result without piping?

``` {r subset data frame}

# We can also subset according to more than 1 criteria. In this case we ask to return a dataframe of people older than 40 and taller than 70. To use more than one filter we use Boolean operator AND or OR. (More info here: https://www.datamentor.io/r-programming/operator/)

# AND
bd_fat_df_age_AND_heigth <- bd_fat_df %>% 
                       filter(age > 40 & height > 70.00)
# OR
bd_fat_df_age_OR_heigth <- bd_fat_df %>% 
                       filter(age > 40 | height > 70.00)
```

Sometimes it is convenient to create another observation in the data frame which is derived from one or more already in the data set. We can use the mutate function to do this. You can use mutate also for a series of other things (e.g change the class attribute of a vector)

By now, you should be able to check out the mutate() funtion documentation. Have a look at it.

``` {r manipulate dataframe}

bd_fat_df_BMI <- bd_fat_df_age_OR_heigth %>% 
  # mutate here is used to calculate the BMI and add it as a new column to the data frame 
                 mutate(BMI = (weight/height^2) * 703 ) %>% 
  # re-order the data.frame columns as we want. everything() is used to call all the columns which haven't been called before
                 select(age, height, weight, BMI, density, percent.fat, everything()) %>%   
  # this command will sort the data frame columns according to the descending BMI order.
  # arrange is reframing the dataframe and desc() is asking to sort them in an descending order.
                 arrange(desc(BMI))   

```
## Plot the data set

Now that we are happy with data frame structure and content we can start to plot some variables. 

R has a lot of visualization packages, every one has some advantages or may be more helpful to some kind of plot then others. ggplot is a quite versatile package to visualize data, still part of the tidyverse. The strength of ggplot is in its grammar, which is standardized for all kinds of plots and allows the generation of publication-ready figures in a flexible manner.
It is a layer function, which means you can keep on adding data ot it.

Let's start with only one variable, e.g. what if we want to know the distribution of percent.fat?

```{r plotting}

# ggplot function is creating the empty graphic for the dataframe and its variable. As you can see the figure currently only contains the axes which are defined through the mapping aesthethics, but the actual plot is missing 

plot_plain<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))

# One way to show the distribution of a variable is a boxplot which shows the quantiles and the median of the data. The qualtiles are dividing the data in top 25% and bottom 25%, the square has 50% of the entire dataset.
# Dots are the outliers. (The x axis in this case is not meaningful) 

plot_box<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))+
  geom_boxplot() 

# If you want to know more about the underlying distribution, try a violin plot:
plot_violin<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))+
  geom_violin() 

# Or combine both:
plot_combine<-plot_violin+
  geom_boxplot(width=0.6)
```

Let's continue with 2 variables. The basic way to show two continuous variables is a scatter plot with one variable on each axis.
```{r}

plot_scatter <-ggplot(bd_fat_df_BMI, aes(x=BMI, y=percent.fat))+
  #Add the points (scatter plot)
                      geom_point()

plot_scatter_regression<-plot_scatter+
  #Adding a linear regression in the plot
                      geom_smooth(method= "lm") 



# Bonus: If you want to find out how the linear regression works, check out this command:
lm(data = bd_fat_df_BMI, BMI ~ percent.fat)
```
Now it's your turn: We would like to add age in the plot as color of the points. Check out the possible aesthetics on the help page of geom_point()

Now we would like to generate the same plot, but for all of the measured circumfences in the dataset. One useful way for this is so-called facetting. This requires some reshaping of the data:

```{r melt}
body_fat_melt <- bd_fat_df_BMI %>% 
                 melt(id.vars=c('density', 'percent.fat','age','weight','height')) 

```
Melt is using the columns you are listing to create a unique ID, then it stacks the remaining columns in 2 columns: one containing the variable name and the other containing the relative value (more info: https://i1.wp.com/www.studytrails.com/wp-content/uploads/2016/09/reshape.png).

Now it's your turn: Check out how your data have changed by comparing bd_fat_df_BMI and body_fat_melt (e.g. using head() and dim())

You'll see that the circumfence columns have been combined to two columns: A variable column containing the original column name and a value column containing the original value. In contrast, the columns defined as ID variables have not been aggregated.

Now we can generate the scatterplot:
```{r facet}
#First we use a similar command as in the previous scatterplot
plot_scatter <- ggplot(body_fat_melt, aes(value, percent.fat))+
                      geom_point() +
                      geom_smooth(method= "lm") 

#You can see clusters of point, because all the circumfences are plotted. But we want to plot each circumfence in a seperate plot and with an adjusted x axis.

plot_scatter_facet<-plot_scatter+
                      facet_wrap(~variable, scales = 'free_x')
```
You can see that some of the circumfences are stronger associated with the percent.fat. One way to quantify the strength of association is correlation:

```{r}
# To calculate Pearson correlation of the variable percentage of fat to all the others
cor(bd_fat_df_BMI, bd_fat_df_BMI$percent.fat)
```
Now it's your turn: Do the derived correlation values agree with your expectations form the plot?
