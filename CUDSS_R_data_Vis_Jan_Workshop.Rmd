---
title: "Explorative data analysis and data visualization in R"
author: "Anika Liu - al862@cam.ac.uk <br> Luca Stefanucci - ls760@cam.ac.uk"
date: "05 Feb 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Index

#### [Explore the data](#S2)
#### [Visualise dataset](#S3)
#### [Example](#S4)
#### [Practice](#S5)

## R Reminder/Disclaimer

+ Basic knowledge of R/coding is preferable, but not essential 
+ Fully charged laptop or charger
+ Have R and Rstudio already installed on your laptop
    + [Install R](https://cran.r-project.org/)
    + [Install Rstudio](https://rstudio.com/products/rstudio/download/#download)

## Import the data 

Firstly, let's import the packages we are going to use for this workshop. 
Packages are sets of functions which you can download and they allow you to extend R basic functions. 
In this workshop we will mainly use "tidyverse". Tidyverse is a collection of packages designed to mung and visualise data, key tasks in data science. For more info about Tidyverse go on: https://www.tidyverse.org/

For this workshop we will need the packages `tidyverse` and `reshape2`. Therefore we first install them (this has to be done only once):
N.B. Remove the hash in your code to install them
```{r}
#install.packages('tidyverse')
#install.packages('reshape2')
```
Next, we load the packages into the current environment:
```{r}
library(tidyverse)
library(reshape2)
```

Secondly, we import the data set we want to work on. For this workshop, we selected some data publicly available at http://www-huber.embl.de/users/klaus/BasicR/bodyfat.rda. They are made available from Bernd Klaus (EMBL) and used as teaching material for a few R courses. You will find the data in the GitHub repository ("bodyfat.csv"). 

```{r}
bd_fat_df <- read_csv("bodyfat.csv", col_names = TRUE) 
# We import and store the data from the file "bodyfat.csv" in an R dataframe. 
# We set col_names to TRUE in this case, as every column has a header and we want to keep it as column name. 
```
Note that the data frame probably has data collected in U.S., so hight and weight units are in pound and inches.

To understand what a function is doing, how to use it and what variables it takes as input ?<function_name> (e.g. ?dim) gives some information about the function and its grammar. help(<function_name>) has a similar use. For example:
```{r}
help(read_csv)
?read_csv
#Or for a broader search:
??read_csv
```

If you can't import the data, most likely the working directory is set to a different path and so R doesn't find the file it is looking for. You have 2 solutions to this problem:
1) change the file path: e.g. `"/path/to/directory/bodyfat.csv"`
2) change the working directory. In this case 2 commands are useful: `getwd()` and `setwd()`. `getwd()` tells you what is the direcotry R is working in (e.g. `~/`) and `setwd()` change the working directory to the one you want (e.g. `"/path/to/directory/"`) so that the file will be in the same directory R is working in. Another alternative is to click your way through: Session-> Set working directory -

## Explore the data {#S2}

It is a good practice to explore a bit your data before starting to work with them. It is helpful to understand what kind of data you are looking at, if there were any mistakes while importing them, if the dataset is "clean" or it needs some wrangling and so on.

Good functions to quickly explore your data frame are `dim()`, `summary()`, `head()`

```{r}
# To show the row and column number of the data frame use dim(). If you are expecting 2000 observation or 30 variables, then you might have spotted a mistake.
dim(bd_fat_df)

# Head is used to visualize the first 10 (in this case) lines of the dataframe
head(bd_fat_df, n = 10) 

# Summary prints a short stats report of the data frame, one per column
summary(bd_fat_df)

```

## Subset the data set

Quite often datasets can grow very big, slowing down all the analysis. So in this cases it might be handy to take only a part of the dataset. It may be also useful to have a smaller dataset when you need to check a new script or to create a training dataset (in this last case the subset would be made in a different way).

Let's say we are just interested in people over 40 y.o. and it doesn't make much sense to have the entire dataset in our analysis. How could we subset the dataframe?

```{r}

# To have only the row that have mathing condition we can use the filter() function, which is a function of the Tidyverse/dplyr package. 
# In this case, filter asks to return only the rows which have a value over 40 in the column age. We store it in another variable, a new dataframe, called "bd_fat_df40"

bd_fat_df40 <- bd_fat_df %>% 
               filter(age > 40 ) 

# N.B.: In R you can use number and some special caracters in the variable name, but not at the beginning of the variable name
```

`%>%`  this simbol is called "pipe".It is a useful way to pass information from one function to the following one. In the previous case I asked to read the bd_fat_df and then to filter out the row that have a value in age of 40 or below.

__Question:__ Have a look at the filter function grammar. How could you have the same result without piping?

``` {r}

# We can also subset according to more than 1 criteria. In this case we ask to return a dataframe of people older than 40 and taller than 70. To use more than one filter we use Boolean operator AND or OR. (More info here: https://www.datamentor.io/r-programming/operator/)

# AND
bd_fat_df_age_AND_heigth <- bd_fat_df %>% 
                       filter(age > 40 & height > 70.00)
# OR
bd_fat_df_age_OR_heigth <- bd_fat_df %>% 
                       filter(age > 40 | height > 70.00)
```

Sometimes it is convenient to create another observation in the data frame which is derived from one or more already in the data set. We can use the mutate function to do this. You can use mutate also for a series of other things (e.g change the class attribute of a vector)

By now, you should be able to check out the `mutate()` funtion documentation. Have a look at it.

``` {r}

bd_fat_df_BMI <- bd_fat_df_age_OR_heigth %>% 
  # mutate here is used to calculate the BMI and add it as a new column to the data frame 
                 mutate(BMI = (weight/height^2) * 703 ) %>% 
  # re-order the data.frame columns as we want. everything() is used to call all the columns which haven't been called before
                 select(age, height, weight, BMI, density, percent.fat, everything()) %>%   
  # this command will sort the data frame columns according to the descending BMI order.
  # arrange is reframing the dataframe and desc() is asking to sort them in an descending order.
                 arrange(desc(BMI))   

```
## Look at the data by groups

One of the strength of R is the possibility to perform vector operations, arithmetics operation or indexes operation. However, sometimes one wants to perform operation just for a sub-group of a vector. This it may be particularly useful when one have categorical variable in our dataset. Categarical variable, usually, describes the data and most of the time one want to preserve these informations when performing operations. In this case group_by (and all its derived functions) can help us in this task.

```{r}
# group_by divides the vector, or the table, in groups defined by one or more variables and perform the operation by these so-defined groups
bd_fat_df_BMI %>% 
      group_by(height <= quantile(height)[3], height > quantile(height)[3]) # here we divide the dataset according to the heights. We will have 2 subgroups having the top 50% height and the bottom 50% heights

#In this example, group_by creates a new logical-class column which has TRUE where the requirement is satisfied.
```

Often use together with `group_by()` is the `summarise()` fuction, it allows to perform group-wise operations.

```{r}
# We could run summarise on our entire dataset (without group filters).
bd_fat_df_BMI %>% summarise(mean = mean(height), sd = sd(height), mean_BMI = mean(BMI))
# however the results won't be much different from a normal function:
mean(bd_fat_df_BMI$height); sd(bd_fat_df_BMI$height); mean(bd_fat_df_BMI$BMI)
```
__Question:__ What other function we could have had used intstead of `summarise` in this example?

```{r}
# More useful is to run summarise after we've grouped our dataset. Here we are grouping according to the hight. Top 50% and bottom 50% to see if there are differences in the BMI
bd_fat_df_BMI %>% 
      group_by(height <= quantile(height)[3], height > quantile(height)[3]) %>% 
      summarise(mean_height = mean(height), sd_height = sd(height), mean_BMI = mean(BMI))

```

## Plot the data set {#S3}

Now that we are happy with data frame structure and content we can start to plot some variables. 

R has a lot of visualization packages, every one has some advantages or may be more helpful to some kind of plot then others. ggplot is a quite versatile package to visualize data, still part of the tidyverse. The strength of ggplot is in its grammar, which is standardized for all kinds of plots and allows the generation of publication-ready figures in a flexible manner.
It is a layer function, which means you can keep on adding data ot it.

Let's start with only one variable, e.g. what if we want to know the distribution of percent.fat?

```{r plotting}

# ggplot function is creating the empty graphic for the dataframe and its variable. As you can see the figure currently only contains the axes which are defined through the mapping aesthethics, but the actual plot is missing 

plot_plain<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))

# One way to show the distribution of a variable is a boxplot which shows the quantiles and the median of the data. The qualtiles are dividing the data in top 25% and bottom 25%, the square has 50% of the entire dataset.
# Dots are the outliers. (The x axis in this case is not meaningful) 

plot_box<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))+
  geom_boxplot() 

# If you want to know more about the underlying distribution, try a violin plot:
plot_violin<-ggplot(bd_fat_df_BMI, mapping = aes( y = percent.fat, x=0))+
  geom_violin() 

# Or combine both:
plot_combine<-plot_violin+
  geom_boxplot(width=0.6)
```

Let's continue with 2 variables. The basic way to show two continuous variables is a scatter plot with one variable on each axis.
```{r}

plot_scatter <-ggplot(bd_fat_df_BMI, aes(x=BMI, y=percent.fat))+
  #Add the points (scatter plot)
                      geom_point()

plot_scatter_regression<-plot_scatter+
  #Adding a linear regression in the plot
                      geom_smooth(method= "lm") 

# Bonus: If you want to find out how the linear regression works, check out this command:
lm(data = bd_fat_df_BMI, BMI ~ percent.fat)
```
Now it's your turn: We would like to add age in the plot as color of the points. Check out the possible aesthetics on the help page of `geom_point()`

Now we would like to generate the same plot, but for all of the measured circumfences in the dataset. One useful way for this is so-called facetting. This requires some reshaping of the data:

```{r melt}
body_fat_melt <- bd_fat_df_BMI %>% 
                 melt(id.vars=c('density', 'percent.fat','age','weight','height')) 

```
Melt is using the columns you are listing to create a unique ID, then it stacks the remaining columns in 2 columns: one containing the variable name and the other containing the relative value (more info: https://i1.wp.com/www.studytrails.com/wp-content/uploads/2016/09/reshape.png).

Now it's your turn: Check out how your data have changed by comparing bd_fat_df_BMI and body_fat_melt (e.g. using head() and dim())

You'll see that the circumfence columns have been combined to two columns: A variable column containing the original column name and a value column containing the original value. In contrast, the columns defined as ID variables have not been aggregated.

Now we can generate the scatterplot:
```{r facet}
#First we use a similar command as in the previous scatterplot
plot_scatter <- ggplot(body_fat_melt, aes(value, percent.fat))+
                      geom_point() +
                      geom_smooth(method= "lm") 

#You can see clusters of point, because all the circumfences are plotted. But we want to plot each circumfence in a seperate plot and with an adjusted x axis.

plot_scatter_facet<-plot_scatter+
                      facet_wrap(~variable, scales = 'free_x')
```
You can see that some of the circumfences are stronger associated with the percent.fat. One way to quantify the strength of association is correlation:

```{r}
# To calculate Pearson correlation of the variable percentage of fat to all the others
cor(bd_fat_df_BMI, bd_fat_df_BMI$percent.fat)
```
Now it's your turn: Do the derived correlation values agree with your expectations form the plot?

## Example {#S5}

## Excercises {#S5}

Now it is your turn.


